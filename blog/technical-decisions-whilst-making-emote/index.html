<!DOCTYPE html>
<html lang="en-us">

<head>
  <meta http-equiv="X-Clacks-Overhead" content="GNU Terry Pratchett" />
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Technical decisions whilst making Emote | Jacob Cons</title>
<meta name="title" content="Technical decisions whilst making Emote" />
<meta name="description" content="A writeup on my thoughts on the different decisions/tradeoffs I made whilst building a backend with Express.js." />
<meta name="keywords" content="" />


<meta property="og:url" content="https://jacobcons.com/blog/technical-decisions-whilst-making-emote/">
  <meta property="og:site_name" content="Jacob Cons">
  <meta property="og:title" content="Technical decisions whilst making Emote">
  <meta property="og:description" content="A writeup on my thoughts on the different decisions/tradeoffs I made whilst building a backend with Express.js.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="blog">
    <meta property="article:published_time" content="2024-05-08T14:45:18+01:00">
    <meta property="article:modified_time" content="2024-05-08T14:45:18+01:00">




  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Technical decisions whilst making Emote">
  <meta name="twitter:description" content="A writeup on my thoughts on the different decisions/tradeoffs I made whilst building a backend with Express.js.">




  <meta itemprop="name" content="Technical decisions whilst making Emote">
  <meta itemprop="description" content="A writeup on my thoughts on the different decisions/tradeoffs I made whilst building a backend with Express.js.">
  <meta itemprop="datePublished" content="2024-05-08T14:45:18+01:00">
  <meta itemprop="dateModified" content="2024-05-08T14:45:18+01:00">
  <meta itemprop="wordCount" content="457">
<meta name="referrer" content="no-referrer-when-downgrade" />

  <style>
  body {
    font-family: Verdana, sans-serif;
    margin: auto;
    padding: 20px;
    max-width: 720px;
    text-align: left;
    background-color: #fff;
    word-wrap: break-word;
    overflow-wrap: break-word;
    line-height: 1.5;
    color: #444;
  }

  h1,
  h2,
  h3,
  h4,
  h5,
  h6,
  strong,
  b {
    color: #222;
  }

  a {
    color: #3273dc;
     
  }

  .title {
    text-decoration: none;
    border: 0;
  }

  .title span {
    font-weight: 400;
  }

  nav a {
    margin-right: 10px;
  }

  textarea {
    width: 100%;
    font-size: 16px;
  }

  input {
    font-size: 16px;
  }

  content {
    line-height: 1.6;
  }

  table {
    width: 100%;
  }

  img {
    max-width: 100%;
  }

  code {
    padding: 2px 5px;
    background-color: #f2f2f2;
  }

  pre code {
    color: #222;
    display: block;
    padding: 20px;
    white-space: pre-wrap;
    font-size: 14px;
    overflow-x: auto;
  }

  div.highlight pre {
    background-color: initial;
    color: initial;
  }

  div.highlight code {
    background-color: unset;
    color: unset;
  }

  blockquote {
    border-left: 1px solid #999;
    color: #222;
    padding-left: 20px;
    font-style: italic;
  }

  footer {
    padding: 25px;
    text-align: center;
  }

  .helptext {
    color: #777;
    font-size: small;
  }

  .errorlist {
    color: #eba613;
    font-size: small;
  }

   
  ul.blog-posts {
    list-style-type: none;
    padding: unset;
  }

  ul.blog-posts li {
    display: flex;
  }

  ul.blog-posts li span {
    flex: 0 0 130px;
  }

  ul.blog-posts li a:visited {
    color: #8b6fcb;
  }

  @media (prefers-color-scheme: dark) {
    body {
      background-color: #333;
      color: #ddd;
    }

    h1,
    h2,
    h3,
    h4,
    h5,
    h6,
    strong,
    b {
      color: #eee;
    }

    a {
      color: #8cc2dd;
    }

    code {
      background-color: #777;
    }

    pre code {
      color: #ddd;
    }

    blockquote {
      color: #ccc;
    }

    textarea,
    input {
      background-color: #252525;
      color: #ddd;
    }

    .helptext {
      color: #aaa;
    }
  }

</style>

<script async src="https://www.googletagmanager.com/gtag/js?id=G-TPGDF4GZ2J"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-TPGDF4GZ2J');
</script></head>

<body>
  <header><a href="/" class="title">
  <h2>Jacob Cons</h2>
</a>
<nav><a href="/">Home</a>


<a href="/blog">Blog</a>

</nav>
</header>
  <main>

<h1>Technical decisions whilst making Emote</h1>
<p>
  <i>
    <time datetime='2024-05-08' pubdate>
      08 May, 2024
    </time>
  </i>
</p>

<content>
  <p>I recently finished building the backend for <a href="https://github.com/jacobcons/Emote" target="_blank">Emote</a>, which is a social network site where you can
only post/comment using exclusively emojis. I fancied writing up some of my thoughts on the different decisions/tradeoffs I
made along the way.</p>
<h3 id="sql">SQL</h3>
<p>I used the query builder knex with most SQL just written raw with the occasional use of knex for dynamic queries when
building it out gets ugly. I prefer writing raw sql since you don&rsquo;t have to learn the quirks and syntax of different ORMs
and can ensure you exactly know the sql being executed. This leads to a simpler mental model, and allows you to write
efficient queries making full use of all of your SQL dialect&rsquo;s features. However, I can see how an ORMs ability to
fetch related data and neatly format it in the json could reduce a lot of boilerplate as I had to make use of PostgreSQL&rsquo;s
JSON functions which can lead to some fairly complex queries. But, most of the time when you need to do anything
slightly complicated the ORM either generates inefficient SQL or it simply cant meet all your requirements and so you
have to do further processing on the data at the application level. Overall, I&rsquo;m far more happy having to write a bit
more boilerplate if it gives me complete control over the SQL.</p>
<h3 id="auth">Auth</h3>
<p>I used JWTs for auth because less state and one less dependency in the form of redis for managing sessions sounded
appealing. The only downside I can see with them is there is no way to revoke tokens on demand. This could be useful, for example,
if a malicious actor got a hold of one. There are remedies to this such as storing a blacklist of tokens or
using refresh tokens, but these all reintroduce state and hence defeat the purpose of using JWTs in the first place.</p>
<h3 id="performance">Performance</h3>
<p>I wrote a script to seed the database with realistic data for over 1M rows. This was useful to test the performance of some
of my more complex queries which I then tweaked to make better.</p>
<h3 id="validation">Validation</h3>
<p>The request body, query and route params are all validated against Joi schemas using reusable middlewares which
carry out the validation and pass control to the error handler if the data is in an invalid format.</p>
<h3 id="error-handling">Error handling</h3>
<p>Thrown errors are automatically passed to the error handler thanks to the express-async-errors package. Unexpectedly
thrown errors are logged and responded with a generic 500 response, whereas intentional custom errors thrown by me respond
with a custom status code and error message. This can occur for example if a friendship with a user is requested to be made
but there is no incoming request from that user.</p>

</content>
<p>
  
</p>

  </main>
  <footer>
</footer>

    
</body>

</html>
